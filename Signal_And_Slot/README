信号与槽机制：
    信号与槽是一个高级接口，应用于对象之间的通信。信号与槽是Qt自定义的通信机制，它是独立于标准的
C/C++语言。因此要正确的处理信号与槽，必须借助一个称谓MOC（Meta Object Compiler）的Qt工具，该工
具是一个C++预处理程序，它为高层次的事件处理自动生成所需要的附加代码。

为什么会有信号与槽：
    在我们所熟知的很多GUI工具包中，窗口小部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，
这个回调函数通常是一个指向某个函数的指针。但是，在QT中信号和槽取代了这些凌乱的函数指针，使得我们
编写这些通信程序更为简洁明了。信号和槽能携带任意数量和任意类型的参数，它们是类型完全安全的，不会
像回调函数那样产生 core dumps。
(core文件时程序在异常退出并满足一定的条件下产生的类似于错误报告的文件，该文件中包含了运行时的内存，
寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等。)


什么是信号：
    当对象改变其状态时，信号就由该对象发射（emit）出去，而且该对象只负责发送信号，它并不知道另一端是谁
在接收信号。这样就做到了真正的信号封装，能确保对象被当做一个真正的软件组织来使用。
    信号的声明和普通的C++函数一样，但是信号没有函数体，信号的返回类型为void。
    使用emit signal（）来发射信号。
    信号可以重载，可以带参数。


什么是槽：
    用于接收信号，但他们是普通的成员函数。一个槽并不知道是否有信号与其链接。而且对象并不了解具体的通信
机制。（由于是普通的成员哈数，所以就存在着访问权限的问题。）


信号与槽的使用对象：
     所有从QObject或其子类派生的类都能够包含信号与槽。


信号与槽的链接方式：
    使用Object的connect方法进行链接，方法具体描述如下：
    [static] QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method,
                                                                                                Qt::ConnectionType type = Qt::AutoConnection)
   sender：发送者指针
   siganl：信号指针
   receiver：接收者指针
    method：成员函数，即槽函数。
在帮组文档中有如下描述：
    You must use the SIGNAL() and SLOT() macros when specifying the signal and the method。
    Note that the signal and slots parameters must not contain any variable names。
    当指定信号和槽方法时，你必须使用SIGNAL（）和SLOT（）宏，注意信号和槽函数的参数必须不能包括任何的变量名。
也就是说只需要指定变量的类型，无需函数名。


信号与槽的关系：
     1.可以将多个信号与一个槽相链接
     2.可以将一个信号与多个槽相链接
     3.信号之间可以互相链接
     4.链接可以移除（使用较少，因为当对象被移除时，Qt会自动移除该对象的所有链接 ）
    （在第一个信号发射后，总是会继续发送下一个信号）


槽函数的执行顺序：
    在自带的帮组文档中有如下一行：
        If a signal is connected to several slots, the slots are activated in the same order as the order the connection was made, when the signal is emitted
        如果一个信号与多个槽函数相连接，当信号被发射时，槽函数将按照他们被链接顺序的同样顺序进行执行。
  但是在网上的文档的说法是，当信号发射时，这些槽函数将一个接一个的执行，但是他们的执行顺序将是随机的、不确定的，我们
  不能认为的指定哪个先执行，哪个后执行。

自定义槽函数：
       在Qt5中，任意的成员函数，普通函数，静态函数
       槽函数需要和信号一致（参数，返回值），由于信号的返回值是void，槽的返回值也是void


如何发送信号：
    在本程序中，SubWidget在点击了按钮之后就使用其槽函数进行信号的发送，然后再主窗口中接收信息，并重新定义槽函数进行处理。


如何查看一个类的信号：
    查看其基类，基类有。


如何处理重载的信号：
    使用函数指针将函数重命名。在使用函数指针时需要加上作用域，这点很重要。
因为信号可以重载，所以槽函数也可以重载，处理的方式和信号的相同


Qt4与Qt5的信号与槽的不同点：
        1.Qt4中信号和槽函数分别要使用SIGNAL和SLOT宏修饰，并且该宏不会进行出错检测。
        2.Qt4中在SIGNAL和SLOT宏中不能添加函数的作用域，但是在Qt5中需要添加。
        3.Qt5比Qt4的信号与槽的处理更加全面，会在编译时检测语法错误，但是Qt4中并没有对宏进行检测错误。


Lambda表达式：
        匿名函数对象，是C++11增加的新特性，可以不定义槽函数，直接写函数的内容。在Qt中配合信号一起使用十分方便。
